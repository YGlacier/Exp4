#ifndef ALE_HPP_
#define ALE_HPP_

#include <cassert>
#include <boost/algorithm/string.hpp>
#include <ale_interface.hpp>
#include <gflags/gflags.h>
#include "dqn.hpp"
#include "replay_memory.hpp"
#include "universal_model.hpp"

DECLARE_bool(fix);

namespace dqn {
namespace ale {

constexpr auto kRawFrameHeight = 210;
constexpr auto kRawFrameWidth = 160;
constexpr auto kCroppedFrameSize = 84;
constexpr auto kInputFrameCount = 4;
constexpr size_t kMinibatchSize = 32;
constexpr auto kGamma = 0.95f;
constexpr auto kMaxActionCount = 18;
constexpr auto kOutputCount = kMaxActionCount;

using DQN = ::dqn::DQN<kInputFrameCount, kCroppedFrameSize, kMinibatchSize,
                       kOutputCount>;
using Transition = StateTransition<DQN::InputFrames, size_t>;
using ReplayMemory = ::dqn::ReplayMemory<DQN::InputFrames, size_t>;
using UniversalModel = ::dqn::UniversalModel<
    kInputFrameCount, kCroppedFrameSize, kMinibatchSize, kOutputCount>;

/**
 * Convert pixel_t (NTSC) to RGB values.
 * Each value range [0,255]
 */
const std::array<int, 3> PixelToRGB(const pixel_t &pixel) {
  constexpr int ntsc_to_rgb[] = {
    0x000000, 0, 0x4a4a4a, 0, 0x6f6f6f, 0, 0x8e8e8e, 0, 0xaaaaaa, 0,
    0xc0c0c0, 0, 0xd6d6d6, 0, 0xececec, 0, 0x484800, 0, 0x69690f, 0,
    0x86861d, 0, 0xa2a22a, 0, 0xbbbb35, 0, 0xd2d240, 0, 0xe8e84a, 0,
    0xfcfc54, 0, 0x7c2c00, 0, 0x904811, 0, 0xa26221, 0, 0xb47a30, 0,
    0xc3903d, 0, 0xd2a44a, 0, 0xdfb755, 0, 0xecc860, 0, 0x901c00, 0,
    0xa33915, 0, 0xb55328, 0, 0xc66c3a, 0, 0xd5824a, 0, 0xe39759, 0,
    0xf0aa67, 0, 0xfcbc74, 0, 0x940000, 0, 0xa71a1a, 0, 0xb83232, 0,
    0xc84848, 0, 0xd65c5c, 0, 0xe46f6f, 0, 0xf08080, 0, 0xfc9090, 0,
    0x840064, 0, 0x97197a, 0, 0xa8308f, 0, 0xb846a2, 0, 0xc659b3, 0,
    0xd46cc3, 0, 0xe07cd2, 0, 0xec8ce0, 0, 0x500084, 0, 0x68199a, 0,
    0x7d30ad, 0, 0x9246c0, 0, 0xa459d0, 0, 0xb56ce0, 0, 0xc57cee, 0,
    0xd48cfc, 0, 0x140090, 0, 0x331aa3, 0, 0x4e32b5, 0, 0x6848c6, 0,
    0x7f5cd5, 0, 0x956fe3, 0, 0xa980f0, 0, 0xbc90fc, 0, 0x000094, 0,
    0x181aa7, 0, 0x2d32b8, 0, 0x4248c8, 0, 0x545cd6, 0, 0x656fe4, 0,
    0x7580f0, 0, 0x8490fc, 0, 0x001c88, 0, 0x183b9d, 0, 0x2d57b0, 0,
    0x4272c2, 0, 0x548ad2, 0, 0x65a0e1, 0, 0x75b5ef, 0, 0x84c8fc, 0,
    0x003064, 0, 0x185080, 0, 0x2d6d98, 0, 0x4288b0, 0, 0x54a0c5, 0,
    0x65b7d9, 0, 0x75cceb, 0, 0x84e0fc, 0, 0x004030, 0, 0x18624e, 0,
    0x2d8169, 0, 0x429e82, 0, 0x54b899, 0, 0x65d1ae, 0, 0x75e7c2, 0,
    0x84fcd4, 0, 0x004400, 0, 0x1a661a, 0, 0x328432, 0, 0x48a048, 0,
    0x5cba5c, 0, 0x6fd26f, 0, 0x80e880, 0, 0x90fc90, 0, 0x143c00, 0,
    0x355f18, 0, 0x527e2d, 0, 0x6e9c42, 0, 0x87b754, 0, 0x9ed065, 0,
    0xb4e775, 0, 0xc8fc84, 0, 0x303800, 0, 0x505916, 0, 0x6d762b, 0,
    0x88923e, 0, 0xa0ab4f, 0, 0xb7c25f, 0, 0xccd86e, 0, 0xe0ec7c, 0,
    0x482c00, 0, 0x694d14, 0, 0x866a26, 0, 0xa28638, 0, 0xbb9f47, 0,
    0xd2b656, 0, 0xe8cc63, 0, 0xfce070, 0
  };
  const auto rgb = ntsc_to_rgb[pixel];
  const auto r = rgb >> 16;
  const auto g = (rgb >> 8) & 0xFF;
  const auto b = rgb & 0xFF;
  return { r, g, b };
}

/**
 * Convert RGB values to a grayscale value [0,255].
 */
uint8_t RGBToGrayscale(const std::array<int, 3> &rgb) {
  assert(rgb[0] >= 0 && rgb[0] <= 255);
  assert(rgb[1] >= 0 && rgb[1] <= 255);
  assert(rgb[2] >= 0 && rgb[2] <= 255);
  // Normalized luminosity grayscale
  return rgb[0] * 0.21 + rgb[1] * 0.72 + rgb[2] * 0.07;
}

uint8_t PixelToGrayscale(const pixel_t pixel) {
  return RGBToGrayscale(PixelToRGB(pixel));
}

DQN::FrameDataSp PreprocessScreenFixed(const ALEScreen &raw_screen) {
  assert(raw_screen.width() == kRawFrameWidth);
  assert(raw_screen.height() == kRawFrameHeight);
  const auto raw_pixels = raw_screen.getArray();
  auto screen = std::make_shared<DQN::FrameData>();
  assert(kRawFrameHeight > kRawFrameWidth);
  const auto x_ratio = kRawFrameWidth / static_cast<double>(kCroppedFrameSize);
  const auto y_ratio = kRawFrameHeight / static_cast<double>(kCroppedFrameSize);
  for (auto i = 0; i < kCroppedFrameSize; ++i) {
    for (auto j = 0; j < kCroppedFrameSize; ++j) {
      const auto first_x = static_cast<int>(std::floor(j * x_ratio));
      assert(first_x >= 0);
      const auto last_x = std::min(
          static_cast<int>(std::floor((j + 1) * x_ratio)), kRawFrameWidth - 1);
      assert(last_x < kRawFrameWidth);
      const auto first_y = static_cast<int>(std::floor(i * y_ratio));
      assert(first_y >= 0);
      const auto last_y = std::min(
          static_cast<int>(std::floor((i + 1) * y_ratio)), kRawFrameHeight - 1);
      assert(last_y < kRawFrameHeight);
      uint8_t resulting_color = 0.0;
      for (auto x = first_x; x <= last_x; ++x) {
        double x_ratio_in_resulting_pixel = 1.0;
        if (x == first_x) {
          x_ratio_in_resulting_pixel = x + 1 - j * x_ratio;
        } else if (x == last_x) {
          x_ratio_in_resulting_pixel = x_ratio * (j + 1) - x;
        }
        assert(x_ratio_in_resulting_pixel >= 0.0 &&
               x_ratio_in_resulting_pixel <= 1.0);
        for (auto y = first_y; y <= last_y; ++y) {
          double y_ratio_in_resulting_pixel = 1.0;
          if (y == first_y) {
            y_ratio_in_resulting_pixel = y + 1 - i * y_ratio;
          } else if (y == last_y) {
            y_ratio_in_resulting_pixel = y_ratio * (i + 1) - y;
          }
          assert(y_ratio_in_resulting_pixel >= 0.0 &&
                 y_ratio_in_resulting_pixel <= 1.0);
          const auto grayscale = PixelToGrayscale(
              raw_pixels[static_cast<int>(y * kRawFrameWidth + x)]);
          resulting_color += (x_ratio_in_resulting_pixel / x_ratio) *
                             (y_ratio_in_resulting_pixel / y_ratio) * grayscale;
        }
      }
      (*screen)[i * kCroppedFrameSize + j] = resulting_color;
    }
  }
  return screen;
}

// This will cause invalid read when run by valgrind because last_x and last_y
// can be more than kRawFrameWidth-1 and kRawFrameHeight-1, reading out of
// raw_pixels array. It seems that the resulting frame data will not change,
// so continue to use this at the moment.
DQN::FrameDataSp PreprocessScreen(const ALEScreen &raw_screen) {
  if (FLAGS_fix) {
    return PreprocessScreenFixed(raw_screen);
  }
  assert(raw_screen.width() == kRawFrameWidth);
  assert(raw_screen.height() == kRawFrameHeight);
  const auto raw_pixels = raw_screen.getArray();
  auto screen = std::make_shared<DQN::FrameData>();
  assert(kRawFrameHeight > kRawFrameWidth);
  const auto x_ratio = kRawFrameWidth / static_cast<double>(kCroppedFrameSize);
  const auto y_ratio = kRawFrameHeight / static_cast<double>(kCroppedFrameSize);
  for (auto i = 0; i < kCroppedFrameSize; ++i) {
    for (auto j = 0; j < kCroppedFrameSize; ++j) {
      const auto first_x = static_cast<int>(std::floor(j * x_ratio));
      const auto last_x = static_cast<int>(std::floor((j + 1) * x_ratio));
      const auto first_y = static_cast<int>(std::floor(i * y_ratio));
      const auto last_y = static_cast<int>(std::floor((i + 1) * y_ratio));
      uint8_t resulting_color = 0.0;
      for (auto x = first_x; x <= last_x; ++x) {
        double x_ratio_in_resulting_pixel = 1.0;
        if (x == first_x) {
          x_ratio_in_resulting_pixel = x + 1 - j * x_ratio;
        } else if (x == last_x) {
          x_ratio_in_resulting_pixel = x_ratio * (j + 1) - x;
        }
        assert(x_ratio_in_resulting_pixel >= 0.0 &&
               x_ratio_in_resulting_pixel <= 1.0);
        for (auto y = first_y; y <= last_y; ++y) {
          double y_ratio_in_resulting_pixel = 1.0;
          if (y == first_y) {
            y_ratio_in_resulting_pixel = y + 1 - i * y_ratio;
          } else if (y == last_y) {
            y_ratio_in_resulting_pixel = y_ratio * (i + 1) - y;
          }
          assert(y_ratio_in_resulting_pixel >= 0.0 &&
                 y_ratio_in_resulting_pixel <= 1.0);
          const auto grayscale = PixelToGrayscale(
              raw_pixels[static_cast<int>(y * kRawFrameWidth + x)]);
          resulting_color += (x_ratio_in_resulting_pixel / x_ratio) *
                             (y_ratio_in_resulting_pixel / y_ratio) * grayscale;
        }
      }
      (*screen)[i * kCroppedFrameSize + j] = resulting_color;
    }
  }
  //  assert(*screen == *PreprocessScreenFix(raw_screen));
  return screen;
}

std::string DrawFrame(const DQN::FrameData &frame) {
  std::ostringstream o;
  for (auto row = 0; row < kCroppedFrameSize; ++row) {
    for (auto col = 0; col < kCroppedFrameSize; ++col) {
      o << std::hex
        << static_cast<int>(frame[row * kCroppedFrameSize + col] / 16);
    }
    o << std::endl;
  }
  return o.str();
}

inline std::string ActionIndexToString(const size_t action_idx) {
  return boost::algorithm::replace_all_copy(
      action_to_string(static_cast<Action>(action_idx)), "PLAYER_A_", "");
}

inline std::string
ActionIndicesToString(const std::vector<size_t> &action_indices) {
  std::ostringstream o;
  o << '[';
  for (auto a : action_indices) {
    o << ActionIndexToString(a) << ',';
  }
  o << ']';
  return o.str();
}

inline std::string
PrintActionEvaluation(const std::unordered_map<size_t, float> &eval) {
  assert(!eval.empty());
  std::ostringstream actions_buf;
  std::ostringstream q_values_buf;
  for (const auto &action_and_value : eval) {
    const auto a_str = ActionIndexToString(action_and_value.first);
    const auto q_str = std::to_string(action_and_value.second);
    const auto column_size = std::max(a_str.size(), q_str.size()) + 1;
    actions_buf.width(column_size);
    actions_buf << a_str;
    q_values_buf.width(column_size);
    q_values_buf << q_str;
  }
  actions_buf << std::endl;
  q_values_buf << std::endl;
  return actions_buf.str() + q_values_buf.str();
}
}
}

#endif /* ALE_HPP_ */
